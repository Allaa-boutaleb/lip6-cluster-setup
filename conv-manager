#!/bin/bash
# Convergence GPU Cluster Manager for LIP6
# Allaa Boutaleb - allaa.boutaleb@lip6.fr
set -e

BLUE='\033[1;34m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
RED='\033[1;31m'
CYAN='\033[1;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

CONV_USER="boutalebm"
TUNNEL_DIR="/tmp/jupyter_tunnels_$(whoami)"
mkdir -p "$TUNNEL_DIR" 2>/dev/null

# Find a free local port for SSH tunneling
find_free_port() {
    python3 -c 'import socket; s=socket.socket(); s.bind(("",0)); print(s.getsockname()[1]); s.close()'
}

# ---- Input validation ----

is_int()  { [[ "$1" =~ ^[0-9]+$ ]]; }
is_wall() { [[ "$1" =~ ^[0-9]+:[0-9]+:[0-9]+$ ]]; }
is_name() { [[ "$1" =~ ^[a-zA-Z0-9_.-]+$ ]]; }
is_path() { [[ "$1" =~ ^[a-zA-Z0-9_.~/-]+$ ]]; }

FUN_FACTS=(
    "The first neural network (Perceptron) was built in 1958 by Frank Rosenblatt."
    "GPT-3 has 175 billion parameters â€” more than the number of stars in the Milky Way."
    "The term 'bug' originated from an actual moth found in a computer relay in 1947."
    "A100 GPUs can perform 312 TFLOPS of mixed-precision operations."
    "The first computer programmer was Ada Lovelace, who wrote algorithms in the 1840s."
    "NVIDIA's name comes from 'invidia', the Latin word for envy."
    "The Python language is named after Monty Python, not the snake."
    "AlphaGo's move 37 in game 2 against Lee Sedol had a 1 in 10,000 chance of being played by a human."
    "The first 1GB hard drive (1980) weighed 550 pounds and cost \$40,000."
    "Transformer models get their name from the 'Attention Is All You Need' paper (2017)."
    "The first email was sent by Ray Tomlinson in 1971 â€” he can't remember what it said."
    "CUDA was introduced by NVIDIA in 2007, revolutionizing GPU computing."
    "The moon landing computer had 74KB of memory â€” less than a single emoji image."
    "Backpropagation was popularized in 1986 but invented in the 1960s."
    "The term 'artificial intelligence' was coined at Dartmouth College in 1956."
    "A single A100 GPU can replace hundreds of CPUs for deep learning workloads."
    "Linux runs on 100% of the world's top 500 supercomputers."
    "The first computer virus, Creeper, was created in 1971 as an experiment."
    "Batch normalization (2015) accidentally became one of deep learning's greatest tricks."
    "The ImageNet dataset that sparked the deep learning revolution contains 14 million images."
)

welcome() {
    local fact="${FUN_FACTS[$((RANDOM % ${#FUN_FACTS[@]}))]}"
    echo ""
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD} â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD}â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD}â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD}â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD}â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} ${BOLD} â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•  â•šâ•â•â•â•${NC}               ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC}   ${DIM}CONVERGENCE Â· LIP6 GPU Cluster Manager${NC}         ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC}   ${DIM}10 nodes | 40 x A100 80GB GPUs | SLURM${NC}        ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "  ${CYAN}ðŸ’¡ ${fact}${NC}"
}

show_menu() {
    echo ""
    echo -e "${BOLD}What do you want to do?${NC}"
    echo ""
    echo -e "  ${GREEN}1${NC})  Launch a new GPU session"
    echo -e "  ${GREEN}2${NC})  Reconnect to a running session"
    echo -e "  ${GREEN}3${NC})  View my jobs"
    echo -e "  ${GREEN}4${NC})  Cancel jobs"
    echo -e "  ${GREEN}5${NC})  Cluster status (GPUs, nodes)"
    echo -e "  ${GREEN}6${NC})  SSH into login node"
    echo -e "  ${GREEN}7${NC})  Disconnect tunnel"
    echo -e "  ${RED}q${NC})  Quit"
    echo ""
}

pick_gpu() {
    echo ""
    echo -e "${BOLD}Which GPU type?${NC}"
    echo ""
    echo -e "  ${GREEN}1${NC})  A100 80GB full     ${DIM}(node01-06, best for large models)${NC}"
    echo -e "  ${GREEN}2${NC})  A100 40GB MIG       ${DIM}(node07-10, good for smaller jobs)${NC}"
    echo ""
    read -p "> " gpu_choice
    case $gpu_choice in
        1) GPU_TYPE="a100_7g.80gb" ;;
        2) GPU_TYPE="a100_3g.40gb" ;;
        *) GPU_TYPE="a100_7g.80gb" ;;
    esac
}

launch_session() {
    pick_gpu

    echo ""
    echo -e "${BOLD}How many GPUs?${NC}"
    echo -e "  ${DIM}Press Enter for 1 (max 4 per node for full, 8 for MIG)${NC}"
    read -p "> " num_gpus
    num_gpus="${num_gpus:-1}"
    if ! is_int "$num_gpus"; then
        echo -e "${RED}GPU count must be a number (e.g. 1, 2, 4).${NC}"
        return
    fi

    echo ""
    echo -e "${BOLD}How long do you need?${NC}"
    echo -e "  ${DIM}Press Enter for 8 hours (format: HH:MM:SS, max 15 days)${NC}"
    read -p "> " wall
    wall="${wall:-08:00:00}"
    if ! is_wall "$wall"; then
        echo -e "${RED}Invalid format. Use HH:MM:SS (e.g. 08:00:00).${NC}"
        return
    fi

    echo ""
    echo -e "${BOLD}Job name?${NC}"
    echo -e "  ${DIM}Press Enter for 'gpu-session' (letters, digits, hyphens, underscores only)${NC}"
    read -p "> " job_name
    job_name="${job_name:-gpu-session}"
    if ! is_name "$job_name"; then
        echo -e "${RED}Invalid job name. Use only letters, digits, hyphens, underscores.${NC}"
        return
    fi

    echo ""
    echo -e "${BOLD}How do you want to work?${NC}"
    echo -e "  ${GREEN}1${NC})  Jupyter Lab (opens in browser)"
    echo -e "  ${GREEN}2${NC})  Terminal only (SSH into compute node)"
    echo -e "  ${GREEN}3${NC})  Both (Jupyter + terminal access)"
    echo -e "  ${GREEN}4${NC})  Submit a custom script"
    echo ""
    read -p "> " mode
    mode="${mode:-1}"
    if ! [[ "$mode" =~ ^[1-4]$ ]]; then
        echo -e "${RED}Choose 1, 2, 3, or 4.${NC}"
        return
    fi

    if [ "$mode" = "4" ]; then
        submit_custom "$num_gpus" "$wall" "$job_name"
        return
    fi

    if [ "$mode" = "2" ]; then
        echo ""
        echo -e "${CYAN}Requesting interactive session: ${num_gpus}x ${GPU_TYPE}, ${wall}...${NC}"
        echo -e "${DIM}This is interactive â€” dies when you disconnect.${NC}"
        echo -e "${DIM}Use option 1 or 3 for persistent Jupyter sessions.${NC}"
        echo ""
        ssh -t conv "salloc --job-name='${job_name}' --nodes=1 --gpus-per-node='${GPU_TYPE}:${num_gpus}' --time='${wall}'"
        return
    fi

    echo ""
    echo -e "${CYAN}Submitting Jupyter Lab: ${num_gpus}x ${GPU_TYPE}, ${wall}...${NC}"

    JOBID=$(ssh conv bash -s "$num_gpus" "$GPU_TYPE" "$wall" "$job_name" << 'REMOTE'
NUM_GPUS="$1"
GPU_TYPE="$2"
WALL="$3"
JOB_NAME="$4"
cat > ~/._conv_jupyter.sh << JOBSCRIPT
#!/bin/bash
#SBATCH --job-name=${JOB_NAME}
#SBATCH --nodes=1
#SBATCH --gpus-per-node=${GPU_TYPE}:${NUM_GPUS}
#SBATCH --time=${WALL}
#SBATCH --mail-type=ALL
#SBATCH --mail-user=allaa.boutaleb@lip6.fr
#SBATCH --output=%x-%j.out
#SBATCH --error=%x-%j.err

source /etc/profile.d/modules.sh
module purge
module load python/anaconda3
eval "\$(conda shell.bash hook)"

JUPYTER_PORT=\$(shuf -i 10000-60000 -n 1)
jupyter lab --ip=0.0.0.0 --no-browser --port=\${JUPYTER_PORT}
JOBSCRIPT
sbatch ~/._conv_jupyter.sh 2>&1 | grep -oP 'Submitted batch job \K[0-9]+'
REMOTE
    )

    if [ -z "$JOBID" ] || ! is_int "$JOBID"; then
        echo -e "${RED}Failed to submit job.${NC}"
        return
    fi

    echo -e "${GREEN}Job $JOBID submitted.${NC} Waiting for it to start..."
    echo -e "${DIM}(Convergence queue can take minutes to hours depending on load)${NC}"
    sleep 5

    local attempts=0
    while true; do
        STATE=$(ssh conv "squeue -j '$JOBID' -h -o '%T' 2>/dev/null" 2>/dev/null)
        if [ "$STATE" = "RUNNING" ]; then
            break
        elif [ "$STATE" = "FAILED" ] || [ "$STATE" = "CANCELLED" ] || [ "$STATE" = "TIMEOUT" ]; then
            echo -e "${RED}Job failed (state: $STATE)${NC}"
            echo -e "Check logs: ${DIM}ssh conv 'cat ~/${job_name}-${JOBID}.err'${NC}"
            return
        elif [ -z "$STATE" ]; then
            local sacct_state
            sacct_state=$(ssh conv "sacct -j '$JOBID' --format=State -X --noheader 2>/dev/null | tr -d ' '" 2>/dev/null)
            if [ -n "$sacct_state" ] && [ "$sacct_state" != "PENDING" ] && [ "$sacct_state" != "RUNNING" ]; then
                echo -e "${RED}Job ended (state: ${sacct_state:-unknown})${NC}"
                echo -e "Check logs: ${DIM}ssh conv 'cat ~/${job_name}-${JOBID}.err'${NC}"
                return
            fi
        fi
        attempts=$((attempts + 1))
        if [ $attempts -gt 120 ]; then
            echo -e "${YELLOW}Still queued after 10 min. Job $JOBID is waiting for GPUs.${NC}"
            echo -e "Use option 2 to connect later, or option 4 to cancel."
            return
        fi
        echo -e "  ${DIM}${STATE:-PENDING}... ($((attempts * 5))s)${NC}"
        sleep 5
    done

    connect_to_job "$JOBID" "$mode" "$job_name"
}

submit_custom() {
    local num_gpus="$1"
    local wall="$2"
    local job_name="$3"

    echo ""
    echo -e "${BOLD}Path to your script on the cluster?${NC}"
    echo -e "  ${DIM}e.g. ~/train.sh (letters, digits, ., _, ~, /, - only)${NC}"
    read -p "> " script_path

    if [ -z "$script_path" ]; then
        echo -e "${RED}No script provided.${NC}"
        return
    fi
    if ! is_path "$script_path"; then
        echo -e "${RED}Invalid path. Allowed characters: letters, digits, ., _, ~, /, -${NC}"
        return
    fi

    echo ""
    echo -e "${CYAN}Submitting ${script_path}: ${num_gpus}x ${GPU_TYPE}, ${wall}...${NC}"

    JOBID=$(ssh conv "sbatch --job-name='${job_name}' --nodes=1 --gpus-per-node='${GPU_TYPE}:${num_gpus}' --time='${wall}' --mail-type=ALL --mail-user=allaa.boutaleb@lip6.fr --output=%x-%j.out --error=%x-%j.err '${script_path}' 2>&1 | grep -oP 'Submitted batch job \K[0-9]+'")

    if [ -z "$JOBID" ] || ! is_int "$JOBID"; then
        echo -e "${RED}Failed to submit job.${NC}"
        return
    fi

    echo -e "${GREEN}Job $JOBID submitted!${NC}"
    echo -e "  Check status:  ${DIM}option 3${NC}"
    echo -e "  Check logs:    ${DIM}ssh conv 'cat ~/${job_name}-${JOBID}.out'${NC}"
    echo -e "  Cancel:        ${DIM}option 4${NC}"
}

connect_to_job() {
    local jobid="$1"
    local mode="${2:-1}"
    local job_name="${3:-gpu-session}"

    local node
    node=$(ssh conv "squeue -j '$jobid' -h -o '%N' 2>/dev/null" 2>/dev/null)
    if [ -z "$node" ] || ! is_name "$node"; then
        echo -e "${RED}Could not find node for job $jobid${NC}"
        return
    fi

    echo -e "${CYAN}Running on ${BOLD}$node${NC}${CYAN}. Waiting for Jupyter...${NC}"

    local url=""
    for i in $(seq 1 30); do
        url=$(ssh conv "grep -o 'http://[^ ]*' ~/*-'${jobid}'.err 2>/dev/null | tail -1" 2>/dev/null)
        if [ -n "$url" ]; then
            break
        fi
        sleep 2
    done

    if [ -z "$url" ]; then
        echo -e "${RED}Jupyter didn't start.${NC}"
        echo -e "Check logs: ${DIM}ssh conv 'cat ~/*-${jobid}.err'${NC}"
        return
    fi

    local remote_port
    remote_port=$(echo "$url" | grep -oP ':\K[0-9]+(?=/)' | head -1)
    if ! is_int "$remote_port"; then
        echo -e "${RED}Could not determine Jupyter port.${NC}"
        return
    fi
    local local_port
    local_port=$(find_free_port)
    local local_url
    local_url=$(echo "$url" | sed "s|http://[^:]*:${remote_port}|http://localhost:${local_port}|")

    echo ""
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}  GPU Session ready!${NC}"
    echo -e "${GREEN}================================================${NC}"
    echo ""
    echo -e "  ${BOLD}Job:${NC}    $jobid"
    echo -e "  ${BOLD}Node:${NC}   $node"
    echo -e "  ${BOLD}Port:${NC}   $remote_port"
    echo -e "  ${BOLD}URL:${NC}    ${CYAN}$local_url${NC}"
    echo ""

    # Start tunnel in background
    ssh -N -J conv -L "${local_port}:localhost:${remote_port}" "${node}.convergence.lip6.fr" &
    local tunnel_pid=$!
    sleep 1
    if ! kill -0 "$tunnel_pid" 2>/dev/null; then
        echo -e "${RED}Tunnel failed to start.${NC}"
        return
    fi
    echo "$tunnel_pid $local_port" > "${TUNNEL_DIR}/${jobid}"
    echo -e "${GREEN}Tunnel running in background (PID $tunnel_pid).${NC}"
    echo -e "${DIM}Use option 7 to disconnect.${NC}"

    echo -e "${CYAN}Opening Jupyter in browser...${NC}"
    if command -v xdg-open &>/dev/null; then
        xdg-open "$local_url" 2>/dev/null &
    elif command -v open &>/dev/null; then
        open "$local_url" &
    fi

    if [ "$mode" = "3" ]; then
        echo ""
        echo -e "${BOLD}To open a terminal on $node, run in another tab:${NC}"
        echo ""
        echo -e "  ${GREEN}ssh -t -J conv ${node}.convergence.lip6.fr${NC}"
        echo ""
        echo -e "${DIM}Or with Kitty:${NC}"
        echo ""
        echo -e "  ${GREEN}kitty +kitten ssh -t -J conv ${node}.convergence.lip6.fr${NC}"
    fi
}

my_jobs() {
    echo ""
    echo -e "${DIM}Loading, please wait...${NC}"
    local output
    output=$(ssh conv "squeue -u '${CONV_USER}' 2>/dev/null" 2>/dev/null)
    if ssh conv "squeue -h -u '${CONV_USER}' 2>/dev/null" 2>/dev/null | grep -q .; then
        echo -e "${BOLD}Your jobs:${NC}"
        echo ""
        echo "$output"
        echo ""
        echo -e "${DIM}Detailed info on a job:${NC}"
        read -p "Job ID (or Enter to skip): " jobid
        if [ -n "$jobid" ]; then
            if ! is_int "$jobid"; then
                echo -e "${RED}Invalid job ID (must be a number).${NC}"
                return
            fi
            echo ""
            ssh conv "sacct -j '$jobid' --format='JobID,JobName,NodeList,AllocTres%80,Start,End,State' -X 2>/dev/null" 2>/dev/null
        fi
    else
        echo -e "${DIM}No running jobs.${NC}"
    fi
    echo ""
}

cancel_job() {
    echo ""
    echo -e "${DIM}Loading, please wait...${NC}"
    local output
    output=$(ssh conv "squeue -u '${CONV_USER}' 2>/dev/null" 2>/dev/null)
    if ! ssh conv "squeue -h -u '${CONV_USER}' 2>/dev/null" 2>/dev/null | grep -q .; then
        echo -e "${DIM}No running jobs to cancel.${NC}"
        return
    fi
    echo -e "${BOLD}Your jobs:${NC}"
    echo ""
    echo "$output"
    echo ""
    echo -e "Enter a job ID to cancel, or ${BOLD}all${NC} to cancel everything."
    read -p "> " jobid
    if [ "$jobid" = "all" ]; then
        ssh conv "for jid in \$(squeue -h -u '${CONV_USER}' -o '%i' 2>/dev/null); do rm -f ~/*-\${jid}.out ~/*-\${jid}.err; done; scancel -u '${CONV_USER}'" 2>/dev/null
        echo -e "${GREEN}All jobs cancelled and log files cleaned up.${NC}"
    elif is_int "$jobid"; then
        ssh conv "scancel '$jobid'; rm -f ~/*-'${jobid}'.out ~/*-'${jobid}'.err" 2>/dev/null
        echo -e "${GREEN}Job $jobid cancelled and log files cleaned up.${NC}"
    elif [ -n "$jobid" ]; then
        echo -e "${RED}Invalid job ID (must be a number, or 'all').${NC}"
    fi
}

cluster_status() {
    echo ""
    echo -e "${DIM}Loading, please wait...${NC}"
    echo ""
    echo -e "${BOLD}Cluster status:${NC}"
    echo ""
    ssh conv "sinfo -p convergence --Node -O 'nodelist:10,cpusstate:16,memory:10,allocmem:10,gres:35,gresused:35,statelong:12' 2>/dev/null" 2>/dev/null
    echo ""
}

connect_existing() {
    echo ""
    echo -e "${DIM}Loading, please wait...${NC}"
    local output
    output=$(ssh conv "squeue -u '${CONV_USER}' 2>/dev/null" 2>/dev/null)
    if ! ssh conv "squeue -h -u '${CONV_USER}' 2>/dev/null" 2>/dev/null | grep -q .; then
        echo -e "${DIM}No running jobs to connect to.${NC}"
        return
    fi

    local job_ids=($(ssh conv "squeue -h -u '${CONV_USER}' -o '%i' 2>/dev/null" 2>/dev/null))
    local jobid=""
    local job_name=""

    if [ ${#job_ids[@]} -eq 1 ]; then
        jobid="${job_ids[0]}"
        job_name=$(ssh conv "squeue -h -j '${jobid}' -o '%j' 2>/dev/null" 2>/dev/null)
        echo -e "Auto-selecting your only running job: ${BOLD}$jobid${NC}"
    else
        echo -e "${BOLD}Your jobs:${NC}"
        echo ""
        echo "$output"
        echo ""
        echo -e "Enter the job ID you want to connect to:"
        read -p "> " jobid
        if [ -n "$jobid" ]; then
            job_name=$(ssh conv "squeue -j '$jobid' -h -o '%j' 2>/dev/null" 2>/dev/null)
        fi
    fi

    if [ -z "$jobid" ]; then
        return
    fi
    if ! is_int "$jobid"; then
        echo -e "${RED}Invalid job ID (must be a number).${NC}"
        return
    fi

    echo ""
    echo -e "${BOLD}How do you want to connect?${NC}"
    echo -e "  ${GREEN}1${NC})  Jupyter Lab (opens in browser)"
    echo -e "  ${GREEN}2${NC})  Terminal only"
    echo -e "  ${GREEN}3${NC})  Both (Jupyter + terminal access)"
    echo ""
    read -p "> " mode
    mode="${mode:-1}"
    if ! [[ "$mode" =~ ^[1-3]$ ]]; then
        echo -e "${RED}Choose 1, 2, or 3.${NC}"
        return
    fi

    if [ "$mode" = "2" ]; then
        local node
        node=$(ssh conv "squeue -j '$jobid' -h -o '%N' 2>/dev/null" 2>/dev/null)
        if [ -z "$node" ] || ! is_name "$node"; then
            echo -e "${RED}Could not find node for job $jobid${NC}"
            return
        fi
        echo -e "${CYAN}Connecting to $node...${NC}"
        ssh -t -J conv "${node}.convergence.lip6.fr"
    else
        connect_to_job "$jobid" "$mode" "${job_name:-gpu-session}"
    fi
}

sever_tunnel() {
    echo ""
    local found=false
    for f in "$TUNNEL_DIR"/*; do
        [ -f "$f" ] || continue
        local tid
        tid=$(basename "$f")
        local pid port
        read -r pid port < "$f"
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  ${GREEN}Job $tid${NC} â€” localhost:$port (PID $pid)"
            found=true
        else
            rm -f "$f"
        fi
    done

    if ! $found; then
        echo -e "${DIM}No active tunnels.${NC}"
        return
    fi

    echo ""
    echo -e "Enter a job ID to disconnect, or ${BOLD}all${NC} to disconnect everything."
    read -p "> " choice
    if [ "$choice" = "all" ]; then
        for f in "$TUNNEL_DIR"/*; do
            [ -f "$f" ] || continue
            read -r pid port < "$f"
            kill "$pid" 2>/dev/null
            rm -f "$f"
        done
        echo -e "${GREEN}All tunnels disconnected.${NC}"
    elif is_int "$choice" && [ -f "${TUNNEL_DIR}/${choice}" ]; then
        read -r pid port < "${TUNNEL_DIR}/${choice}"
        kill "$pid" 2>/dev/null
        rm -f "${TUNNEL_DIR}/${choice}"
        echo -e "${GREEN}Tunnel for job $choice disconnected.${NC}"
    elif [ -n "$choice" ]; then
        echo -e "${RED}Invalid choice.${NC}"
    fi
}

# Entry point
welcome

while true; do
    show_menu
    read -p "> " choice
    case $choice in
        1) launch_session ;;
        2) connect_existing ;;
        3) my_jobs ;;
        4) cancel_job ;;
        5) cluster_status ;;
        6) ssh conv ;;
        7) sever_tunnel ;;
        q|Q) echo -e "\n${DIM}Bye!${NC}\n"; exit 0 ;;
        *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
done
